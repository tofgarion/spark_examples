** The Sort_Heap algorithm

The ~Sort_Heap~ algorithm will convert take a ~Heap~ representing a heap data structure, and will 
sort the elements in the heap.

Its signature reads 
#+BEGIN_SRC ada
procedure Sort_Heap(H : in out Heap)
#+END_SRC

*** Specification of Sort_Heap

The specification is as follows:

#+BEGIN_SRC ada
procedure Sort_Heap(H : in out Heap) with
     Pre => Is_Heap_Def(H),
     Post => Multiset_Unchanged(H.A,H.A'Old)
     and then Sorted(H.A(1 .. H'Old.Size));
#+END_SRC

The only precondition is that ~H~ should represent a Heap data structure.
The postcondition expresses the fact that after the procedure the occurences of each element in ~H.A~ 
hasn't changed and that ~H.A~ is sorted by ascending order on the indexes constituting the heap *before* the call to the procedure.

*** Implementation of Sort_Heap

With the help of the previously coded procedure [[Pop_Heap.org][Pop_Heap]], ~Sort_Heap~ is quite easy to implement:

#+BEGIN_SRC ada
procedure Sort_Heap(H : in out Heap)
   is
      Interm : Heap := H with ghost;
      N : constant Integer := H.Size;
   begin
      Interm := H;
      pragma assert(Interm.Size <= N);
      For J in  reverse 1 .. N loop
         Interm := H;

         Pop_Heap(H);
 
         pragma Loop_Invariant(H.A(J) >= H.A(1));
         pragma Loop_Invariant(H.Size = J-1);
         pragma Loop_Invariant(Is_Heap_Def(H));
         pragma Loop_Invariant(Multiset_Unchanged(H.A,H'Loop_Entry.A));
         pragma Loop_Invariant(Lower_Bound(H.A(J .. N), H.A(J)));
         pragma Loop_Invariant(Sorted(H.A(J .. N)));
      end loop;
   end Sort_Heap;
#+END_SRC

The ghost variable ~Interm~ will be used to compare the state of ~H~ during the execution of the loop with the previous iteration;
~N~ stores the initial size of the heap, which will be useful to make a ~for~ loop.

The working principle of the algorithm is to call the ~Pop_Heap~ procedure on ~H~ as many times as there are elements in the heap.

The loop invariants here ensure that:
- The current element being removed is greater that the new first element of the heap. This loop invariant enables the provers to verify that we are correctly sorting the array.
- ~H.Size = J-1~ This gives us a relation between ~J~ and ~H.Size~, needed to prove we are working on the correct ranges.
- ~H~ represents a heap data structure (between indexes ~1~ and ~H.Size~, the other elements are either the sorted array, or unspecified)
- The array ~H.A~ can be obtained through permutations of the elements of ~H~ at the entry of the loop.
- ~H.A(J)~ is a lower bound of the array ~H.A(J .. N)~, i.e. a lower bound for the elements already sorted.
- ~H.A~ is sorted between indexes ~J~ and ~N~


with those annotations, when using ~gnatprove~ everything is proved. The proof is again 5 minutes long, because ~gnatprove~ reproves the algorithm [[Pop_Heap.org][Pop_Heap]].
