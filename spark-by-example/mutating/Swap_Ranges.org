** The Swap_Ranges algorithm

   The ~swap_ranges~ algorithm exchanges the contents of two arrays.
   Its signature reads:
   
   ~ procedure Swap_Ranges(A : in out T_Arr; B: in out T_Arr)~
   
*** Specification of Swap_Ranges

    The specification of ~swap_ranges~ is the following:

    #+BEGIN_SRC ada
    procedure Swap_Ranges(A : in out T_Arr; B: in out T_Arr) with
     Pre => A'Length = B'Length,
     Post => A'Old = B and then B'Old = A;
    #+END_SRC

    The precondition expresses the fact that ~A~ and ~B~ must have the same length.
    The postcondition expresses the fact that the values in ~A~ and ~B~ have actually
    been exchanged.

*** Implementation of Swap_Ranges

    #+BEGIN_SRC ada
     procedure Swap_Ranges (A : in out T_Arr; B : in out T_Arr) is
   begin

      for I in A'Range loop
         Swap (A (I), B (B'First + (I - A'First)));

         pragma Loop_Invariant
           (B'Loop_Entry (B'First .. B'First + (I - A'First)) =
            A (A'First .. I));
         pragma Loop_Invariant
           (A'Loop_Entry (A'First .. I) =
            B (B'First .. B'First + (I - A'First)));
         pragma Loop_Invariant
           (if
              B'First + (I - A'First) < B'Last
            then
              B'Loop_Entry (B'First + (I - A'First) + 1 .. B'Last) =
              B (B'First + (I - A'First) + 1 .. B'Last));
         pragma Loop_Invariant
           (if
              I < A'Last
            then
              A'Loop_Entry (I + 1 .. A'Last) = A (I + 1 .. A'Last));

      end loop;
   end Swap_Ranges;
    #+END_SRC

    The loop invariants specify that :
      - the ~I~ first values of the arrays have been exchanged.
      - the next values are still the same and they can be exchanged in the next
	entry in loop.

     Using ~gnatprove~, everything is proved.
