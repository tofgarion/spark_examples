* The Remove_Copy algorithm

  The ~remove_copy~ algorithm copies the values of an array in
  another array but deletes every occurence of a given value.
  It also modifies an argument which will be the last index
  at which the second array has been modified.
  Its signature reads:
  ~procedure Remove_Copy (A : T_Arr; B : in out T_Arr; Val : T; K : out Natural)~

** The predicates used
*** The Multiset_Retain_Rest predicate

   First, we need to define a predicate to check if two arrays have
   the same number of occurences of each value, except for one.
   It can be expressed as:
   #+BEGIN_SRC ada
   function Multiset_Retain_Rest
     (A   : T_Arr;
      B   : T_Arr;
      Val : T) return Boolean is
    (for all X in T => (if X /= Val then Occ (A, X) = Occ (B, X)));
   #+END_SRC

   The predicate will return true if and only if for each value in
   ~T~ different from ~Val~, the number of occurences of this value
   in the two arrays is the same.

*** The Remove_Count predicate

    The ~remove_count~ predicate is quite simple:
    #+BEGIN_SRC ada
    function Remove_Count
     (A   : T_Arr;
      Val : T) return Natural is
     (A'Length - Occ (A, Val))  with
      Pre  => A'Length > 0,
      Post => Remove_Count'Result in 0 .. A'Length ;
    #+END_SRC

    This predicate returns the number of values different from a given
    value in an array.
    
** Specification of Remove_Copy

   The specification of ~remove_copy~ is the following:
   #+BEGIN_SRC ada
     procedure Remove_Copy
     (A   :        T_Arr;
      B   : in out T_Arr;
      Val :        T;
      K   : in out Natural) with
      Pre            => B'Length = A'Length and then B'Last < Positive'Last,
      Contract_Cases =>
      (A'Length = 0 => (B'Old = B and then K'Old = K),
       A'Length > 0 =>
         (K in B'First - 1 .. B'Last
          and then K = B'First + Remove_Count (A, Val) - 1
          and then (for all L in B'First .. K => B (L) /= Val)
          and then (for all L in K + 1 .. B'Last => B (L) = B'Old (L))
          and then
          (if
             K >= B'First
           then
             Multiset_Retain_Rest (A, B (B'First .. K), Val))));
   #+END_SRC

   The preconditions express the fact that ~A~ and ~B~ are the
   same length, and ~B'Last~ is strictly less than ~Positive'Last~
   because during the execution ~K~ could be equal to ~B'Last + 1~.
   
   The contract cases express the fact that:
   - if ~A~ is empty then nothing has changed.
   - if ~A~ is not empty then:
     1. ~K~ is in ~B'First - 1 .. B'Last~. It corresponds with
	the last index at which ~B~ has been modified. If ~K~
	is equal to ~B'First - 1~, it means that ~B~ has not
	been changed.
     2. The range in which ~B~ has been modified has a length
	equal to the number of values different from ~Val~ in
	~A~.
     3. In the sub-array of ~B~ that has been modified, every
	value is different from ~Val~.
     4. in the sub-array of ~B~ that has not been modified,
	each value has not changed.
     5. if ~B~ has been modified, then ~A~ and the modified
	sub-array of ~B~ have the same occurences of each value
	except for ~Val~.

** Implementations of Remove_Copy

*** A first implementation

   A first implementation of ~Remove_Copy~ could be:
   #+BEGIN_SRC ada
   procedure Remove_Copy
     (A   :        T_Arr;
      B   : in out T_Arr;
      Val :        T;
      K   : in out Natural)
   is
      J      : Integer := A'First - 1;

   begin
      if A'Length > 0 then
      K := B'First;

      for J in A'Range loop
         if A (J) /= Val then
            B (K)  := A (J);
            K := K + 1;
         end if;

         pragma Loop_Invariant
           (K = B'First + Remove_Count (A (A'First .. J), Val));
         pragma Loop_Invariant
           (if K = B'First then (for all L in A'First .. J => A (L) = Val));
         pragma Loop_Invariant
           (if
              K > B'First
            then
              Multiset_Retain_Rest
                (A (A'First .. J),
                 B (B'First .. K - 1),
                 Val));
         pragma Loop_Invariant (for all L in B'First .. K - 1 => B (L) /= Val);
         pragma Loop_Invariant
           (for all L in K .. B'Last => B (L) = B'Loop_Entry (L));
         end loop;
      K := K - 1;
      end if;
      
   end Remove_Copy;
   #+END_SRC

   The loop invariants specify that:
   - ~K~ is equal to ~B'First~ plus the number of values different from
     ~Val~ encountered until now.
   - if ~K~ has not been increased, then each value of ~A~ at index
     less or equal than ~J~ is equal to ~Val~.
   - if ~K~ has been increased, then the predicate ~Multiset_Retain_Rest~
     is verified for the sub-arrays given.
   - each value of ~B~ that has been modified is different from ~Val~.
   - each value of ~B~ that has not been modified is the same as before.

     With this specification and implementation, ~gnatprove~ cannot prove
     the loop invariant with ~Multiset_Retain_Rest~. Indeed, the predicate
     checks a recursive property for each value of ~T~. We will need to
     help the prover to manage to prove the function.

*** The Make_Prove_Multiset procedure and its lemma

**** First Lemma

     A first lemma will be defined. It states that each value 
     of an array ~A~ is equal to ~Val~, then for a value ~E~
     different from ~Val~, ~Occ(A,E) = 0~. Given the fact that
     GNAT does not yet use inductive reasoning, we need to
     help it prove the lemma.

     Its specification is:
     #+BEGIN_SRC ada
     procedure Lemma_1 (A : T_Arr; E, Val : T) with
      Ghost,

      Pre => (for all L in A'First .. A'Last => A (L) = Val) and then E /= Val,
      Post => Occ (A, E) = 0;
     #+END_SRC
    
     Its implementation is:
     #+BEGIN_SRC ada
     procedure Lemma_1 (A : T_Arr; E, Val : T) is
   begin
      if A'Length = 0 then
         return;
      end if;
      Lemma_1 (Remove_Last (A), E, Val);
   end Lemma_1;
     #+END_SRC

     First, we specify the stop condition, which is when ~A~ is empty.
     Then, we use the lemma on the same array without its last value.
     It will prove the property for ~Remove_Last(A)~ and with the
     definition of ~Occ_Def~ (~if A(A'Last) /= E then
     Result = Occ_Def(Remove_Last(A),E)~, and the prover just calculated
     ~Occ_Def(Remove_Last(A),E)~), it will prove the lemma for ~A~.

**** The Make_Prove_Multiset procedure

     The ~Make_Prove_Multiset~ procedure is here to help the prover
     to prove some properties by guiding him. We specify the income
     properties and the outcomes properties in the .ads file:

     #+BEGIN_SRC ada
     procedure Make_Prove_Multiset (A : T_Arr; B : T_Arr; Val : T) with
      Ghost,
      Pre => A'Length > 0
      and then B'Length > 0
      and then
      (if B'Length = 1 then (for all L in A'First .. A'Last - 1 => A (L) = Val)
       else
         Multiset_Retain_Rest
           (Remove_Last (A),
            Remove_Last(B),
            Val))
      and then A (A'Last) = B (B'Last),
      Post => Multiset_Retain_Rest (A, B, Val);
     #+END_SRC

     ~A~ and ~B~ must not be empty and their last value is the same.
     The precondition expresses two different cases:
     - if ~B~ has only one element, then all elements of ~Remove_Last(A)~
       are equal to ~Val~.
     - if not, then the ~Multiset_Retain_Rest~ is verified with the two arrays
       without their last value.
       
     The postcondition expresses the fact that the ~Multiset_Retain_Rest~
     predicate will be verified with the two complete arrays.

     Its implementation is:

     #+BEGIN_SRC ada
     procedure Make_Prove_Multiset (A : T_Arr; B : T_Arr; Val : T) is
      V : T := A (A'Last);
   begin
      for E in T loop
         if E /= Val then
            if B'Length = 1 then
               Lemma_1 (Remove_Last (A), E, Val);
            end if;
         pragma Loop_Invariant
           (for all F in T'First .. E =>
              (if F /= Val then Occ (A, F) = Occ (B, F)));
      end loop;

   end Make_Prove_Multiset;
     #+END_SRC

     To verify the predicate, the prover needs to do it with a loop.
     
