** The Random_Shuffle algorithm

The ~Random_Shuffle~ algorithms aims to randomly rearanges the lelements of an array. Its signature reads:

#+BEGIN_SRC ada
procedure Random_Shuffle(A : in out T_Arr)
#+END_SRC

*** Formal specification and predicates used

In this part we will give a formal specification for ~Random_Shuffle~ and define several predicates that will
help us in the proof of this function.

**** Formal specification of Random_Shuffle

As mentionned earlier, ~Random_Shuffle~ should rearrange the elements of ~A~ in a "random" order.
That being said, it is not easy to mathematicaly define what a true random rearrangement is, so we will only require 
that ~Random_Shuffle~ acts as a permutation, i.e. the number of occurences of each element of ~A~ remains constant when calling ~Random_Shuffle~.
With this consideration in mind, we can write a specification for ~Random_Shuffle~:
#+BEGIN_SRC ada
procedure Random_Shuffle (A : in out T_Arr) with
     Post => Multiset_Unchanged(A'Old,A);
#+END_SRC

The postcondition ensures that the elements of ~A~ are simply permuted by ~Random_Shuffle~.

**** The predicate Multiset_Unchanged

The predicate ~Multiset_Unchanged~ which is used in the specification of ~Random_Shuffle~ checks wether two arrays are a permutation of eachother, 
i.e. each element of the first array appears the same number of time in the second array, but not necessarly in the same order. This is done with the help of
the ~Occ~  predicate, defined in chapter 3 for the function [[../non-mutating/Count.org][Count]]. ~Multiset_Unchanged~ is defined as follows:

#+BEGIN_SRC ada
function Multiset_Unchanged
     (A : T_Arr;
      B : T_Arr) return Boolean is
     (for all K in T => Occ (A, K) = Occ (B, K)) with
       Pre => A'Length = B'Length;
#+END_SRC

Here we simply check that for two arrays of same length the number of occurences of a givent ~T~ is the same for both arrays.
It is important to do the check on all elements of ~T~ and not only on the elements of ~A~, otherwise the solvers cannot determine that 
we can obtain ~B~ by permuting the elements of ~A~ and vice-versa.

*** Implementations of Random_Shuffle

In this section we will give several implementations for ~Random_Shuffle~, starting by the easiest one, 
which cannot be proved by the SMT solvers, and will progressively explain what can be done in order to help the 
automatic provers to prove everything.

**** First Implementation

The first implementation makes use of the [[Swap.Org][Swap]] function proved earlier in this chapter.
We also assume that we have a function ~Random_Number~ which returns a number selecter randomly between 
two given bounds. As mentionned earlier, we won't focus much on this function, as our specification for ~Random_Shuffle~
has no real constraints on the "randomness" of the function.
Our first implementation is as follows:

#+BEGIN_SRC ada
 procedure Random_Shuffle (A : in out T_Arr) 
 is
    J : Positive
 begin
      
      for I in A'Range loop
	 J := Random_Number(A'First, I);
     
	Swap(A(I),A(J));
	pragma Loop_Invariant(Multiset_Unchanged(A,A'Loop_Entry));

      end loop;
   end Random_Shuffle;
#+END_SRC

There are a few issues with this implementation:
- The use of ~Swap~ on an array introduces aliasing warnings
- The solvers cannot autimaticaly prove that swaping two elements of an array is a permutation, so the only loop invariant cannot be proved.

We have already encountered the first solution, and an easy workaround is to manualy do the swap with
an intermediary variable. This solution however does not permit the proof of the loop invariant. We will have
to help the solvers understand that swapping two values in an array is a permutation.

**** Second implementation : Manual proof
We will here help the solvers prove our function by adding a manual proof in the form of ghost code. This section makes
use of the examples given in the [[https://docs.adacore.com/spark2014-docs/html/ug/gnatprove_by_example/manual_proof.html#manual-proof-using-ghost-code][SPARK 2014 User's Guide]].

***** The Swap_Array function

In order to proove the loop invariant, we would like to write a function which takes an array and two indexes as
parameters, and swaps the two values found at these indexes, and which would prove that this opperation is a 
permutation on the array.
Its specification would then be:

#+BEGIN_SRC ada
function Swap_Array(A : T_Arr; I : Positive; J : Positive) return T_Arr with
      Pre => A'Length >= 1 and then I in A'Range and then J in A'Range and then I >= J,
      Post =>A'First = Swap_Array'Result'First 
      and then A'Last = Swap_Array'Result'Last 
      and then A(I) = Swap_Array'Result(J) 
      and then A(J) = Swap_Array'Result(I)
     and then (for all K in A'Range => (if I/=K and then J /= K then A(K) = Swap_Array'Result(K)))
     and then Multiset_Unchanged(A,Swap_Array'Result);
#+END_SRC

The precondition simply express that ~I~ and ~J~ are valid indexes; the postconditions express that:
-The result array has the same range as the input array
-the values at indexes ~I~ and ~J~ were swapped
-All values found a indexes different to ~I~ and ~J~ remain unchanged
-The resulting array is a permutation of the input array.

The implementation (without SPARK annotations) is quite straightforward:

#+BEGIN_SRC ada 
function Swap_Array(A : T_Arr; I : Positive; J : Positive)return T_Arr is
      Result : T_Arr (A'Range) :=A;
      Temp : T := Result(I);
   begin
      Result(I) := Result(J);
      Result(J) := Temp;
      return Result;
   end Swap_Array;
#+END_SRC

With this current implementation, the desired result is achieved, but the last postcondition is still not prooved.

***** The Is_Set predicate

The ~Is_Set~ predicate is defined as follows:

#+BEGIN_SRC ada
function Is_Set(A : T_Arr; I : Positive; V : T; B : T_Arr) return Boolean 
   is
     (A'First = B'First and then A'Last = B'Last
      and then B(I) = V
      and then (for all J in A'Range =>
                    (if i /= J then B(J) = A(J)))) with
   Pre => I in A'Range;
#+END_SRC

The ~Is_Set~ predicates verifies that B is equal to A, except for the value found at index ~I~, which should
be equal to ~V~. This predicate will be usefull when comparing the occurences of certain values before and 
after an array has it's vales changed (when swapping two values for instance).

***** The Occ_Eq lemma
The ~Occ_Eq~ lemma is an example of how we can manualy prove a property that the SMT solvers struggle, or cannot prove on their own.
This lemma, in the form of a procedure verifies that if two arrays are equal, then the number of occurences of a given value is equal in both arrays,
and so for every possible value. Its specification is:

#+BEGIN_SRC ada
procedure Occ_Eq(A : T_Arr; B : T_Arr; E : T) with
     Pre => A = B,
     Post => Occ(A,E) = Occ(B,E);
#+END_SRC

The specification alone isn't sufficient in order to prove the lemma, a guided proof must be written in the body of the procedure :

#+BEGIN_SRC ada
procedure Occ_Eq(A: T_Arr; B : T_Arr; E : T) is
   begin
      if A'Length = 0 then
      return;
   end if;
   
   if A(A'Last) = E then 
      pragma assert(B(B'Last) = E);
   else
      pragma assert(B(B'Last) /= E);
   end if;
   
   Occ_Eq(Remove_Last(A),Remove_Last(B),E);
end Occ_Eq;
#+END_SRC
The property is proved inductively:
-If both arrays are empty then there is nothing to prove.
-If the arrays are of length greater than zero, then:
 - We verify that if the last value of ~A~ is equal to ~E~ then so is the last value of ~B~, and if the last value of ~A~ is different from ~E~ then is is the last value of ~B~, which given the definition of [[../non-mutating/Count.org][Occ]] will help prove that the contribution of the last index of ~A~ and ~B~ are the same in ~Occ(A,E)~ and ~Occ(B,E)~.
 - We verify that the nuber of occurences of ~E~ in ~A~ and ~B~ is the same, for the other indexes.

***** The Occ_Set lemma

~Occ_Set~ gives the relation between the occurences of a given value in an array before and after changing one of its indexes.
It's specification is as follows:

#+BEGIN_SRC ada
procedure Occ_Set (A : T_Arr; B : T_Arr; I : Positive; V ,E : T) with
     Pre => I in A'Range and then Is_Set(A,I,V,B),
     Post =>
       (if V = A(I) then Occ(B,E) = Occ(A,E)
              elsif V = E then Occ(B,E) = Occ(A,E) + 1
              elsif A(I) = E then Occ(B,E) = Occ(A,E) - 1
              else Occ(B,E)=Occ(A,E));
#+END_SRC

The precondition expresses the fact that B should be equal to A, to the exception of the value at index ~I~,
which should be equal to ~V~.
The postconditions are the mathematical relations we expect to find concerning the number of occurences of ~E~ in ~A~ and ~B~.

The proof being:

#+BEGIN_SRC ada
procedure Occ_Set(A: T_arr; B : T_Arr; I : Positive; V,E : T) 
is 
   Tmp : T_Arr := Remove_Last(A);
begin
   if A'Length = 0 then 
      return;
   end if;
   
   if I = A'Last then
      Occ_Eq(Tmp,Remove_Last(B),E);
   else
      Tmp(I) := V;
      Occ_Eq(Remove_Last(B),Tmp,E);
      Occ_Set(Remove_Last(A),Tmp,I,V,E);
   end if;
end Occ_Set;
#+END_SRC

The proof is once again inductive:
- If ~A~ is empty then there is nothing to prove
- If ~I~ is equal to A'Last, i.e. ~A~ and ~B~ only differ by the last index, then we verify that the number of occurences of ~E~ is equal on both arrays on the rest of the indexes, the provers can then deduce the postconditions depending on the values of ~E~ and ~V~.
- If I isn't equal to A'Last, then we call ~Occ_Eq~ on the first indexes of ~B~ and on the first indexes of ~A~, but with the value at index ~I~ equal to ~V~ (the array ~tmp~). This tells the solvers that ~Tmp = Remove_Last(B)~, and can deduce that hte contribution of the last index is the same in ~Occ(A,E)~ and ~Occ(B,E)~. We then proceed to prove the property on the rest of the indexes.

With these lemmas proved, we can now move on to the proof of the las postcondition of ~Swap_Array~.

***** The Pove_Perm procedure

We will write a ghost procedure in the declarative part of ~Swap_Array~ which will guide the automatic solvers to verify our last psotcondition.
We write this procedure in the declarative part of ~Swap_Array~ so we can access all the parametters and intermediate variables used in the 
function, but we could have written it in another package, it would simply have required that we give the working arrays as parameters to the ghost procedure.

Since we wrote the procedure in the declarative part of ~Swap_Array~ to be able to use all the working variables,
we need to look at the full implementation of ~Swap_Array~ in order to understand how it functions:

#+BEGIN_SRC ada
function Swap_Array(A : T_Arr; I : Positive; J : Positive)return T_Arr is
      Result : T_Arr (A'Range) :=A;
      Temp : T := Result(I);
      
      --ghost variables
      
      Interm : T_Arr (A'Range) with Ghost;
      
      -- ghost procedure
      
      procedure Prove_Perm with Ghost,
        Pre => I in A'Range and then J in A'Range
        and then Is_Set(A,I,A(J),Interm)
        and then Is_Set(Interm,J,A(I),Result),
        Post => Multiset_Unchanged(A,Result)
      is
      begin
         for V in T loop
            Occ_Set(A,Interm,I,A(J),V);
            Occ_Set(Interm,Result,J,A(I),V);
            pragma Loop_Invariant
              (for all F in T'First .. V =>
                 Occ(Result,F) = Occ(A,F));
         end loop;
      end Prove_Perm;
      
   begin
      Result(I) := Result(J);
      Interm := Result; -- ghost
      
      pragma Assert(Is_Set(A,I,A(J),Result));

      Result(J) := Temp;
      
      pragma Assert(Is_Set(Interm,J,A(I),Result));
      Prove_Perm; --ghost
      return Result;
   end Swap_Array;
#+END_SRC

We first declare a ghost variable ~Interm~ which will hold the state of the ~Array~ on which we do the swap, after the first value assingment.

The proof procedure, called here ~Prove_Perm~ requires that ~I~ and ~J~ are valid indexes, and that ~Interm~ should be equal to ~A~,
to the exception of the index ~I~ which should have the value ~A(J)~, and that ~Result~ should be equal to ~Interm~,
to the exception of the value at index ~J~ which should be equal to ~A(I)~.
The prostcondition of this procedure is what we are trying to prove.

To do so we will manualy apply our lemma on all values ~V~ of ~T~ concerning the number of occurences of ~V~ in the arrays.
This is done with the ~for~ loop, and the loop invariant is here to accumulate the results of our lemmas. Note that when the loop reaches its end, then ~V = T'Last~ and the loop invariant is
~for all E in T'First .. T'Last then Occ(Result,E) = Occ(A,E)~ which is exactly the poscondition we are trying to prove.

In the body of ~Swap_Array~ we then initialize ~Interm~ to the correct value, assert the preconditions of the proof procedure, and then call the proof procedure so that the solvers apply our proof to ~Swap_Array~.

With this implementation and proof lemmas, ~gnatprove~ manages to proove everything.


**** A word on the implementation of Random_Number

For the purpose of our exercise we didn't look in detail how the random number generator is specified and implemented, nevertheless we present here a 
crude version of a random number generator, using the Ada numerics package. It should be noted that the [[http://docs.adacore.com/spark2014-docs/html/lrm/the-standard-library.html#random-number-generation-a-5-2][SPARK 2014 reference manual]] indicates that using the 
package ~Ada.Numerics.Discrete_Random~ isn't forbiddent in SPAKR 2014, but the associated functions have side effects and cannot therfore be formaly prooved.
A better solution would be to manualy code a random number generator, as it was done in [[https://github.com/fraunhoferfokus/acsl-by-example/blob/master/StandardAlgorithms/mutating/random_shuffle/random_number.c][ACSL by Example]]. Nevertheless our specification and implementation is:

#+BEGIN_SRC ada
function Random_Number(First : Positive; Last : Positive) return Positive with
     Pre => Last >= First,
     Post => Random_Number'Result in First .. Last;
#+END_SRC 

#+BEGIN_SRC ada
function Random_Number(First : Positive; Last : Positive) return Positive is
      
      subtype Rng is Positive range First .. Last;
      package Alea is new Ada.Numerics.Discrete_Random(Rng);
      use Alea;
      
      Rnd_Gen : Generator;
      Result : Integer;
      
   begin
      Reset(Rnd_Gen);
      Result := random(Rnd_Gen);
      if Result < First then
	 Result := First;
      elsif Result > Last then
	 Result := Last;
      end if;
      
      return Result;
      
   end Random_Number;
#+END_SRC

This implementation uses the package ~Ada.Numerics.Discrete_Random~ out of conveniance, and declares a new
andom generator at each call of the function, which isn't ideal beacause two calls with same arguments close enough in time would yield the same result, but since two consecutive calls to this function should be with different parameters 
there should be no issues.

