** The Random_Shuffle algorithm

The ~Random_Shuffle~ algorithms aims to randomly rearanges the lelements of an array. Its signature reads:

#+BEGIN_SRC ada
procedure Random_Shuffle(A : in out T_Arr)
#+END_SRC

*** Formal specification and predicates used

In this part we will give a formal specification for ~Random_Shuffle~ and define several predicates that will
help us in the proof of this function.

**** Formal specification of Random_Shuffle

As mentionned earlier, ~Random_Shuffle~ should rearrange the elements of ~A~ in a "random" order.
That being said, it is not easy to mathematicaly define what a true random rearrangement is, so we will only require 
that ~Random_Shuffle~ acts as a permutation, i.e. the number of occurences of each element of ~A~ remains constant when calling ~Random_Shuffle~.
With this consideration in mind, we can write a specification for ~Random_Shuffle~:
#+BEGIN_SRC ada
procedure Random_Shuffle (A : in out T_Arr) with
     Post => Multiset_Unchanged(A'Old,A);
#+END_SRC

The postcondition ensures that the elements of ~A~ are simply permuted by ~Random_Shuffle~.

**** The predicate Multiset_Unchanged

The predicate ~Multiset_Unchanged~ which is used in the specification of ~Random_Shuffle~ checks wether two arrays are a permutation of eachother, 
i.e. each element of the first array appears the same number of time in the second array, but not necessarly in the same order. This is done with the help of
the ~Occ~  predicate, defined in chapter 3 for the function [[../non-mutating/Count.org][Count]]. ~Multiset_Unchanged~ is defined as follows:

#+BEGIN_SRC ada
function Multiset_Unchanged
     (A : T_Arr;
      B : T_Arr) return Boolean is
     (for all K in T => Occ (A, K) = Occ (B, K)) with
       Pre => A'Length = B'Length;
#+END_SRC

Here we simply check that for two arrays of same length the number of occurences of a givent ~T~ is the same for both arrays.
It is important to do the check on all elements of ~T~ and not only on the elements of ~A~, otherwise the solvers cannot determine that 
we can obtain ~B~ by permuting the elements of ~A~ and vice-versa.

*** Implementations of Random_Shuffle

In this section we will give several implementations for ~Random_Shuffle~, starting by the easiest one, 
which cannot be proved by the SMT solvers, and will progressively explain what can be done in order to help the 
automatic provers to prove everything.

**** First Implementation

The first implementation makes use of the [[Swap.Org][Swap]] function proved earlier in this chapter.
We also assume that we have a function ~Random_Number~ which returns a number selecter randomly between 
two given bounds. As mentionned earlier, we won't focus much on this function, as our specification for ~Random_Shuffle~
has no real constraints on the "randomness" of the function.
Our first implementation is as follows:

#+BEGIN_SRC ada
 procedure Random_Shuffle (A : in out T_Arr) 
 is
    J : Positive
 begin
      
      for I in A'Range loop
	 J := Random_Number(A'First, I);
     
	Swap(A(I),A(J));
	pragma Loop_Invariant(Multiset_Unchanged(A,A'Loop_Entry));

      end loop;
   end Random_Shuffle;
#+END_SRC

There are a few issues with this implementation:
- The use of ~Swap~ on an array introduces aliasing warnings
- The solvers cannot autimaticaly prove that swaping two elements of an array is a permutation, so the only loop invariant cannot be proved.

We have already encountered the first solution, and an easy workaround is to manualy do the swap with
an intermediary variable. This solution however does not permit the proof of the loop invariant. We will have
to help the solvers understand that swapping two values in an array is a permutation.

**** Second implementation : Manual proof
We will here help the solvers prove our function by adding a manual proof in the form of ghost code. This section makes
use of the examples given in the [[https://docs.adacore.com/spark2014-docs/html/ug/gnatprove_by_example/manual_proof.html#manual-proof-using-ghost-code][SPARK 2014 User's Guide]].

***** The Swap_Array function

In order to proove the loop invariant, we would like to write a function which takes an array and two indexes as
parameters, and swaps the two values found at these indexes, and which would prove that this opperation is a 
permutation on the array.
Its specification would then be:

#+BEGIN_SRC ada
function Swap_Array(A : T_Arr; I : Positive; J : Positive) return T_Arr with
      Pre => A'Length >= 1 and then I in A'Range and then J in A'Range and then I >= J,
      Post =>A'First = Swap_Array'Result'First 
      and then A'Last = Swap_Array'Result'Last 
      and then A(I) = Swap_Array'Result(J) 
      and then A(J) = Swap_Array'Result(I)
     and then (for all K in A'Range => (if I/=K and then J /= K then A(K) = Swap_Array'Result(K)))
     and then Multiset_Unchanged(A,Swap_Array'Result);
#+END_SRC

The precondition simply express that ~I~ and ~J~ are valid indexes; the postconditions express that:
-The result array has the same range as the input array
-the values at indexes ~I~ and ~J~ were swapped
-All values found a indexes different to ~I~ and ~J~ remain unchanged
-The resulting array is a permutation of the input array.

The implementation (without SPARK annotations) is quite straightforward:

#+BEGIN_SRC ada 
function Swap_Array(A : T_Arr; I : Positive; J : Positive)return T_Arr is
      Result : T_Arr (A'Range) :=A;
      Temp : T := Result(I);
   begin
      Result(I) := Result(J);
      Result(J) := Temp;
      return Result;
   end Swap_Array;
#+END_SRC

With this current implementation, the desired result is achieved, but the last postcondition is still not prooved.


***** The Is_Set predicate

The ~Is_Set~ predicate is defined as follows:

#+BEGIN_SRC ada
function Is_Set(A : T_Arr; I : Positive; V : T; B : T_Arr) return Boolean 
   is
     (A'First = B'First and then A'Last = B'Last
      and then B(I) = V
      and then (for all J in A'Range =>
                    (if i /= J then B(J) = A(J)))) with
   Pre => I in A'Range;
#+END_SRC

The ~Is_Set~ predicates verifies that B is equal to A, except for the value found at index ~I~, which should
be equal to ~V~. This predicate will be usefull when comparing the occurences of certain values before and 
after an array has it's vales changed (when swapping two values for instance).

***** The Occ_Eq lemma
The ~Occ_Eq~ lemma is an example of how we can manualy prove a property that the SMT solvers struggle, or cannot prove on their own.
This lemma, in the form of a procedure verifies that if two arrays are equal, then the number of occurences of a given value is equal in both arrays,
and so for every possible value. Its specification is:

#+BEGIN_SRC ada
procedure Occ_Eq(A : T_Arr; B : T_Arr; E : T) with
     Pre => A = B,
     Post => Occ(A,E) = Occ(B,E);
#+END_SRC

The specification alone isn't sufficient in order to prove the lemma, a guided proof must be written in the body of the procedure :

#+BEGIN_SRC ada
procedure Occ_Eq(A: T_Arr; B : T_Arr; E : T) is
   begin
      if A'Length = 0 then
      return;
   end if;
   
   if A(A'Last) = E then 
      pragma assert(B(B'Last) = E);
   else
      pragma assert(B(B'Last) /= E);
   end if;
   
   Occ_Eq(Remove_Last(A),Remove_Last(B),E);
end Occ_Eq;
#+END_SRC
The property is proved inductively:
-If both arrays are empty then there is nothing to prove.
-If the arrays are of length greater than zero, then:
 - We verify that if the last value of ~A~ is equal to ~E~ then so is the last value of ~B~, and if the last value of ~A~ is different from ~E~ then is is the last value of ~B~, which given the definition of [[../non-mutating/Count.org][Occ]] will help prove that the contribution of the last index of ~A~ and ~B~ are the same in ~Occ(A,E)~ and ~Occ(B,E)~.
 - We verify that the nuber of occurences of ~E~ in ~A~ and ~B~ is the same, for the other indexes.


***** The Occ_Set lemma

~Occ_Set~ gives the relation between the occurences of a given value in an array before and after changing one of its indexes.
It's specification is as follows:

#+BEGIN_SRC ada
procedure Occ_Set (A : T_Arr; B : T_Arr; I : Positive; V ,E : T) with
     Pre => I in A'Range and then Is_Set(A,I,V,B),
     Post =>
       (if V = A(I) then Occ(B,E) = Occ(A,E)
              elsif V = E then Occ(B,E) = Occ(A,E) + 1
              elsif A(I) = E then Occ(B,E) = Occ(A,E) - 1
              else Occ(B,E)=Occ(A,E));
#+END_SRC

The precondition expresses the fact that B should be equal to A, to the exception of the value at index ~I~,
which should be equal to ~V~.
The postconditions are the mathematical relations we expect to find concerning the number of occurences of ~E~ in ~A~ and ~B~.

The proof being:

#+BEGIN_SRC ada
procedure Occ_Set(A: T_arr; B : T_Arr; I : Positive; V,E : T) 
is 
   Tmp : T_Arr := Remove_Last(A);
begin
   if A'Length = 0 then 
      return;
   end if;
   
   if I = A'Last then
      Occ_Eq(Tmp,Remove_Last(B),E);
   else
      Tmp(I) := V;
      Occ_Eq(Remove_Last(B),Tmp,E);
      Occ_Set(Remove_Last(A),Tmp,I,V,E);
   end if;
end Occ_Set;
#+END_SRC
