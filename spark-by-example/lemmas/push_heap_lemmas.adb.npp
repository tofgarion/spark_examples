package body Push_Heap_Lemmas with
SPARK_Mode
is
   procedure Occ_Eq (A : T_Arr; B : T_Arr; E : T) with
     Ghost,
     Pre => A = B,
     Post => Occ(A,E) = Occ(B,E);

   procedure Occ_Eq(A: T_Arr; B : T_Arr; E : T) is
   begin
      if A'Length = 0 then
      return;
   end if;

   if A(A'Last) = E then
      pragma assert(B(B'Last) = E);
   else
      pragma assert(B(B'Last) /= E);
   end if;

   Occ_Eq(Remove_Last(A),Remove_Last(B),E);
end Occ_Eq;

procedure Occ_Set(A: T_arr; B : T_Arr; I : Positive; V,E : T)
is
   Tmp : T_Arr := Remove_Last(A);
begin
   if A'Length = 0 then
      return;
   end if;

   if I = A'Last then
      Occ_Eq(Tmp,Remove_Last(B),E);
   else
      Tmp(I) := V;
      Occ_Eq(Remove_Last(B),Tmp,E);
      Occ_Set(Remove_Last(A),Tmp,I,V,E);
   end if;
   end Occ_Set;

    procedure Make_Prove(H : Heap; A_Save, A_Old : T_Arr; V_Old, V : T; Hole : Positive)
      is
      begin
--           for E in T loop
--              Occ_Eq
--                (A_Save (A_Save'First .. Hole - 1),
--                 H.A (H.A'First .. Hole - 1),
--                 E);
--              Occ_Eq (A_Save (Hole + 1 .. H.Size), H.A (Hole + 1 .. H.Size), E);
--
--              pragma Loop_Invariant
--                (for all F in T'First .. E =>
--                   Occ (A_Save (A_Save'First .. Hole - 1), F) =
--                   Occ (H.A (H.A'First .. Hole - 1), F)
--                   and then
--                     Occ (A_Save (Hole + 1 .. H.Size), F) =
--                     Occ (H.A (Hole + 1 .. H.Size), F));
--           end loop;
--           pragma Assert
--             (Multiset_Unchanged
--                (A_Save (A_Save'First .. Hole - 1),
--                 H.A (H.A'First .. Hole - 1)));
--           pragma Assert
--             (Multiset_Unchanged
--                (A_Save (Hole + 1 .. H.Size),
--                 H.A (Hole + 1 .. H.Size)));

         for E in T loop
            Occ_Set (A_Save, H.A, Hole, H.A (Hole), E);
            pragma Loop_Invariant
              (for all F in T'First .. E =>
                 (if F = V_Old then Occ (H.A, F) = Occ (A_Save, F) - 1
                  elsif F = H.A (Hole) then Occ (H.A, F) = Occ (A_Save, F) + 1
                  else Occ (H.A, F) = Occ (A_Save, F)));
         end loop;
         pragma Assert (Multiset_Add (A_Save, H.A, V_Old));
         pragma Assert (Multiset_Minus (A_Save, H.A, H.A (Hole)));
         pragma Assert
           (Multiset_Retain_Rest_Double (A_Save, H.A, H.A (Hole), V_Old));
         for E in T loop
            null;
            pragma Loop_Invariant
              (for all F in T'First .. E =>
                 (if F = H.A (Hole) then Occ (H.A, F) = Occ (A_Old, F) + 1
                  elsif F = V then Occ (H.A, F) = Occ (A_Old, F) - 1
                  else Occ (H.A, F) = Occ (A_Old, E)));
         end loop;
   end Make_Prove;

end Push_Heap_Lemmas;

